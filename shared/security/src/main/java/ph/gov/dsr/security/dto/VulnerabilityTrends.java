package ph.gov.dsr.security.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import ph.gov.dsr.security.entity.VulnerabilitySeverity;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * DTO for vulnerability trends analysis results
 * 
 * @author DSR Development Team
 * @version 3.0.0
 * @since 2024-12-28
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class VulnerabilityTrends {

    private String dateRange;
    private Integer totalScans;
    private Map<LocalDateTime, Integer> vulnerabilityCountsByDate;
    private Map<VulnerabilitySeverity, Long> vulnerabilityCountsBySeverity;
    private Double averageVulnerabilitiesPerScan;
    private Integer totalVulnerabilities;
    private Integer resolvedVulnerabilities;
    private Integer openVulnerabilities;
    private Integer falsePositives;
    private Double resolutionRate;
    private Double falsePositiveRate;
    private Map<String, Integer> vulnerabilityCountsByType;
    private Map<String, Integer> vulnerabilityCountsByTarget;
    private Map<String, Double> trendsByPeriod;
    private String trendDirection; // IMPROVING, DEGRADING, STABLE
    private Double trendPercentage;
    private LocalDateTime generatedAt;
    private String summary;
    private String recommendations;
    
    /**
     * Calculate resolution rate percentage
     */
    public double getResolutionRatePercentage() {
        if (totalVulnerabilities == null || totalVulnerabilities == 0) {
            return 0.0;
        }
        int resolved = resolvedVulnerabilities != null ? resolvedVulnerabilities : 0;
        return (double) resolved / totalVulnerabilities * 100.0;
    }
    
    /**
     * Calculate false positive rate percentage
     */
    public double getFalsePositiveRatePercentage() {
        if (totalVulnerabilities == null || totalVulnerabilities == 0) {
            return 0.0;
        }
        int falsePos = falsePositives != null ? falsePositives : 0;
        return (double) falsePos / totalVulnerabilities * 100.0;
    }
    
    /**
     * Get critical vulnerability count
     */
    public long getCriticalVulnerabilityCount() {
        return vulnerabilityCountsBySeverity != null ? 
            vulnerabilityCountsBySeverity.getOrDefault(VulnerabilitySeverity.CRITICAL, 0L) : 0L;
    }
    
    /**
     * Get high vulnerability count
     */
    public long getHighVulnerabilityCount() {
        return vulnerabilityCountsBySeverity != null ? 
            vulnerabilityCountsBySeverity.getOrDefault(VulnerabilitySeverity.HIGH, 0L) : 0L;
    }
    
    /**
     * Get medium vulnerability count
     */
    public long getMediumVulnerabilityCount() {
        return vulnerabilityCountsBySeverity != null ? 
            vulnerabilityCountsBySeverity.getOrDefault(VulnerabilitySeverity.MEDIUM, 0L) : 0L;
    }
    
    /**
     * Get low vulnerability count
     */
    public long getLowVulnerabilityCount() {
        return vulnerabilityCountsBySeverity != null ? 
            vulnerabilityCountsBySeverity.getOrDefault(VulnerabilitySeverity.LOW, 0L) : 0L;
    }
    
    /**
     * Check if trend is improving
     */
    public boolean isTrendImproving() {
        return "IMPROVING".equals(trendDirection);
    }
    
    /**
     * Check if trend is degrading
     */
    public boolean isTrendDegrading() {
        return "DEGRADING".equals(trendDirection);
    }
    
    /**
     * Check if trend is stable
     */
    public boolean isTrendStable() {
        return "STABLE".equals(trendDirection);
    }
    
    /**
     * Get overall security posture score (0-100)
     */
    public double getSecurityPostureScore() {
        double score = 100.0;
        
        // Deduct points for unresolved vulnerabilities
        if (openVulnerabilities != null && totalVulnerabilities != null && totalVulnerabilities > 0) {
            double openRate = (double) openVulnerabilities / totalVulnerabilities;
            score -= openRate * 50; // Up to 50 points deduction
        }
        
        // Deduct points for critical and high vulnerabilities
        long critical = getCriticalVulnerabilityCount();
        long high = getHighVulnerabilityCount();
        
        score -= Math.min(critical * 10, 30); // Up to 30 points for critical
        score -= Math.min(high * 5, 20); // Up to 20 points for high
        
        // Bonus for good resolution rate
        if (resolutionRate != null && resolutionRate > 0.8) {
            score += (resolutionRate - 0.8) * 50; // Up to 10 bonus points
        }
        
        return Math.max(Math.min(score, 100.0), 0.0);
    }
}
