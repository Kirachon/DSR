package ph.gov.dsr.interoperability.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * DTO for compliance reports
 *
 * @author DSR Development Team
 * @version 3.0.0
 * @since 2024-12-28
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Schema(description = "Compliance report")
public class ComplianceReport {

    @Schema(description = "Report identifier", example = "RPT-2024-001")
    private String reportId;

    @Schema(description = "Report title", example = "Monthly Compliance Report")
    private String title;

    @Schema(description = "Report period", example = "2024-01-01 to 2024-01-31")
    private String reportPeriod;

    @Schema(description = "Report generation date")
    private LocalDateTime generatedAt;

    @Schema(description = "Report generated by")
    private String generatedBy;

    @Schema(description = "Report format", example = "DETAILED")
    private String reportFormat;

    @Schema(description = "Overall compliance statistics")
    private ComplianceStatistics overallStatistics;

    @Schema(description = "Statistics by compliance standard")
    private Map<String, ComplianceStatistics> standardStatistics;

    @Schema(description = "Identified compliance gaps")
    private List<ComplianceGap> complianceGaps;

    @Schema(description = "Compliance recommendations")
    private List<ComplianceRecommendation> recommendations;

    @Schema(description = "Executive summary")
    private String executiveSummary;

    @Schema(description = "Key findings")
    private List<String> keyFindings;

    @Schema(description = "Risk assessment summary")
    private String riskAssessment;

    @Schema(description = "Trend analysis")
    private Map<String, Object> trendAnalysis;

    @Schema(description = "Action items")
    private List<String> actionItems;

    @Schema(description = "Next review date")
    private LocalDateTime nextReviewDate;

    @Schema(description = "Report status", example = "FINAL")
    private String status;

    @Schema(description = "Report metadata")
    private Map<String, Object> metadata;

    /**
     * Check if report has compliance gaps
     */
    public boolean hasComplianceGaps() {
        return complianceGaps != null && !complianceGaps.isEmpty();
    }

    /**
     * Check if report has recommendations
     */
    public boolean hasRecommendations() {
        return recommendations != null && !recommendations.isEmpty();
    }

    /**
     * Get critical gaps count
     */
    public int getCriticalGapsCount() {
        if (complianceGaps == null) {
            return 0;
        }
        return (int) complianceGaps.stream()
                .filter(ComplianceGap::isCritical)
                .count();
    }

    /**
     * Get high priority recommendations count
     */
    public int getHighPriorityRecommendationsCount() {
        if (recommendations == null) {
            return 0;
        }
        return (int) recommendations.stream()
                .filter(ComplianceRecommendation::isHighPriority)
                .count();
    }

    /**
     * Get overall compliance score
     */
    public Double getOverallComplianceScore() {
        if (overallStatistics != null) {
            return overallStatistics.getComplianceRate();
        }
        return null;
    }

    /**
     * Get compliance level
     */
    public String getComplianceLevel() {
        if (overallStatistics != null) {
            return overallStatistics.getComplianceLevel();
        }
        return "UNKNOWN";
    }

    /**
     * Check if compliance is acceptable
     */
    public boolean isComplianceAcceptable() {
        Double score = getOverallComplianceScore();
        return score != null && score >= 80.0;
    }

    /**
     * Get report summary
     */
    public String getReportSummary() {
        Double score = getOverallComplianceScore();
        String scoreText = score != null ? String.format("%.1f%%", score) : "N/A";

        return String.format("Compliance Report %s: %s compliance (%d gaps, %d recommendations)",
                           reportId, scoreText,
                           hasComplianceGaps() ? complianceGaps.size() : 0,
                           hasRecommendations() ? recommendations.size() : 0);
    }

    /**
     * Get standards coverage
     */
    public List<String> getCoveredStandards() {
        if (standardStatistics == null) {
            return new java.util.ArrayList<>();
        }
        return new java.util.ArrayList<>(standardStatistics.keySet());
    }

    /**
     * Get compliance statistics for specific standard
     */
    public ComplianceStatistics getStatisticsForStandard(String standard) {
        if (standardStatistics == null) {
            return null;
        }
        return standardStatistics.get(standard);
    }

    /**
     * Check if report is final
     */
    public boolean isFinal() {
        return "FINAL".equalsIgnoreCase(status);
    }

    /**
     * Check if report is draft
     */
    public boolean isDraft() {
        return "DRAFT".equalsIgnoreCase(status);
    }

    /**
     * Get days until next review
     */
    public long getDaysUntilNextReview() {
        if (nextReviewDate == null) {
            return -1;
        }
        return java.time.temporal.ChronoUnit.DAYS.between(LocalDateTime.now(), nextReviewDate);
    }

    /**
     * Check if next review is overdue
     */
    public boolean isNextReviewOverdue() {
        return nextReviewDate != null && LocalDateTime.now().isAfter(nextReviewDate);
    }

    /**
     * Get report age in days
     */
    public long getReportAgeInDays() {
        if (generatedAt == null) {
            return 0;
        }
        return java.time.temporal.ChronoUnit.DAYS.between(generatedAt, LocalDateTime.now());
    }
}