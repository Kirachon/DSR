<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DeduplicationServiceImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DSR Data Management Service</a> &gt; <a href="index.source.html" class="el_package">ph.gov.dsr.datamanagement.service.impl</a> &gt; <span class="el_source">DeduplicationServiceImpl.java</span></div><h1>DeduplicationServiceImpl.java</h1><pre class="source lang-java linenums">package ph.gov.dsr.datamanagement.service.impl;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;
import ph.gov.dsr.datamanagement.dto.DeduplicationRequest;
import ph.gov.dsr.datamanagement.dto.DeduplicationResponse;
import ph.gov.dsr.datamanagement.service.DeduplicationService;

import java.time.LocalDateTime;
import java.util.*;

/**
 * Production implementation of DeduplicationService with fuzzy matching algorithms
 * 
 * @author DSR Development Team
 * @version 3.0.0
 * @since 2024-12-23
 */
@Service
@Profile(&quot;!no-db&quot;)
<span class="nc" id="L23">@RequiredArgsConstructor</span>
<span class="nc" id="L24">@Slf4j</span>
public class DeduplicationServiceImpl implements DeduplicationService {

    // In-memory storage for demonstration (in production, this would be database-backed)
<span class="nc" id="L28">    private final Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; entityStorage = new HashMap&lt;&gt;();</span>
<span class="nc" id="L29">    private final Map&lt;String, Map&lt;String, Object&gt;&gt; algorithmConfig = new HashMap&lt;&gt;();</span>
<span class="nc" id="L30">    private final Map&lt;String, Integer&gt; statistics = new HashMap&lt;&gt;();</span>
    
    // Default matching thresholds
    private static final double HIGH_CONFIDENCE_THRESHOLD = 0.9;
    
    @Override
    public DeduplicationResponse findDuplicates(DeduplicationRequest request) {
<span class="nc" id="L37">        log.info(&quot;Finding duplicates for entity type: {} using algorithm: {}&quot;, </span>
<span class="nc" id="L38">                request.getEntityType(), request.getMatchingAlgorithm());</span>
        
<span class="nc" id="L40">        long startTime = System.currentTimeMillis();</span>
        
<span class="nc" id="L42">        DeduplicationResponse response = new DeduplicationResponse();</span>
<span class="nc" id="L43">        response.setProcessedAt(LocalDateTime.now());</span>
<span class="nc" id="L44">        response.setMatches(new ArrayList&lt;&gt;());</span>
        
        try {
<span class="nc" id="L47">            List&lt;Map&lt;String, Object&gt;&gt; existingEntities = entityStorage.getOrDefault(</span>
<span class="nc" id="L48">                    request.getEntityType(), new ArrayList&lt;&gt;());</span>
            
<span class="nc" id="L50">            List&lt;DeduplicationResponse.DuplicateMatch&gt; matches = new ArrayList&lt;&gt;();</span>
            
<span class="nc bnc" id="L52" title="All 2 branches missed.">            for (Map&lt;String, Object&gt; existingEntity : existingEntities) {</span>
<span class="nc" id="L53">                double similarity = calculateSimilarity(</span>
<span class="nc" id="L54">                        request.getEntityData(), </span>
                        existingEntity, 
<span class="nc" id="L56">                        request.getMatchingFields(),</span>
<span class="nc" id="L57">                        request.getMatchingAlgorithm()</span>
                );
                
<span class="nc bnc" id="L60" title="All 2 branches missed.">                if (similarity &gt;= request.getMatchThreshold()) {</span>
<span class="nc" id="L61">                    DeduplicationResponse.DuplicateMatch match = createDuplicateMatch(</span>
                            existingEntity, similarity, request);
<span class="nc" id="L63">                    matches.add(match);</span>
                }
<span class="nc" id="L65">            }</span>
            
            // Sort by similarity score (highest first)
<span class="nc" id="L68">            matches.sort((a, b) -&gt; Double.compare(b.getSimilarityScore(), a.getSimilarityScore()));</span>
            
            // Limit results
<span class="nc bnc" id="L71" title="All 2 branches missed.">            if (matches.size() &gt; request.getMaxResults()) {</span>
<span class="nc" id="L72">                matches = matches.subList(0, request.getMaxResults());</span>
            }
            
<span class="nc" id="L75">            response.setMatches(matches);</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">            response.setHasDuplicates(!matches.isEmpty());</span>
<span class="nc" id="L77">            response.setTotalMatches(matches.size());</span>
<span class="nc" id="L78">            response.setRecommendation(determineRecommendation(matches, request.getMatchThreshold()));</span>
            
            // Update statistics
<span class="nc" id="L81">            updateStatistics(&quot;duplicatesFound&quot;, matches.size());</span>
            
<span class="nc" id="L83">        } catch (Exception e) {</span>
<span class="nc" id="L84">            log.error(&quot;Error finding duplicates&quot;, e);</span>
<span class="nc" id="L85">            response.setHasDuplicates(false);</span>
<span class="nc" id="L86">            response.setTotalMatches(0);</span>
<span class="nc" id="L87">            response.setRecommendation(&quot;ERROR&quot;);</span>
<span class="nc" id="L88">        }</span>
        
<span class="nc" id="L90">        long processingTime = System.currentTimeMillis() - startTime;</span>
<span class="nc" id="L91">        response.setProcessingTimeMs(processingTime);</span>
        
<span class="nc" id="L93">        log.info(&quot;Duplicate search completed. Found {} matches in {}ms&quot;, </span>
<span class="nc" id="L94">                response.getTotalMatches(), processingTime);</span>
        
<span class="nc" id="L96">        return response;</span>
    }

    @Override
    public boolean isDuplicate(String entityType, Map&lt;String, Object&gt; entityData, double threshold) {
<span class="nc" id="L101">        log.debug(&quot;Checking if entity is duplicate for type: {} with threshold: {}&quot;, entityType, threshold);</span>
        
<span class="nc" id="L103">        DeduplicationRequest request = new DeduplicationRequest();</span>
<span class="nc" id="L104">        request.setEntityType(entityType);</span>
<span class="nc" id="L105">        request.setEntityData(entityData);</span>
<span class="nc" id="L106">        request.setMatchThreshold(threshold);</span>
<span class="nc" id="L107">        request.setMaxResults(1);</span>
        
<span class="nc" id="L109">        DeduplicationResponse response = findDuplicates(request);</span>
<span class="nc" id="L110">        return response.isHasDuplicates();</span>
    }

    @Override
    public void mergeDuplicates(UUID primaryEntityId, UUID duplicateEntityId, String entityType) {
<span class="nc" id="L115">        log.info(&quot;Merging duplicates: {} &lt;- {} for type: {}&quot;, primaryEntityId, duplicateEntityId, entityType);</span>
        
        // In production, this would:
        // 1. Merge entity data in database
        // 2. Update references to point to primary entity
        // 3. Mark duplicate entity as merged/inactive
        // 4. Create audit trail
        
<span class="nc" id="L123">        updateStatistics(&quot;duplicatesResolved&quot;, 1);</span>
<span class="nc" id="L124">    }</span>

    @Override
    public void markAsNotDuplicates(UUID entityId1, UUID entityId2, String entityType) {
<span class="nc" id="L128">        log.info(&quot;Marking entities as not duplicates: {} and {} for type: {}&quot;, </span>
                entityId1, entityId2, entityType);
        
        // In production, this would store the &quot;not duplicate&quot; relationship
        // to prevent future false positive matches
<span class="nc" id="L133">    }</span>

    @Override
    public Map&lt;String, Object&gt; getDeduplicationStatistics() {
<span class="nc" id="L137">        log.debug(&quot;Getting deduplication statistics&quot;);</span>
        
<span class="nc" id="L139">        Map&lt;String, Object&gt; stats = new HashMap&lt;&gt;();</span>
<span class="nc" id="L140">        stats.put(&quot;totalDuplicatesFound&quot;, statistics.getOrDefault(&quot;duplicatesFound&quot;, 0));</span>
<span class="nc" id="L141">        stats.put(&quot;duplicatesResolved&quot;, statistics.getOrDefault(&quot;duplicatesResolved&quot;, 0));</span>
<span class="nc" id="L142">        stats.put(&quot;duplicatesPending&quot;, Math.max(0, </span>
<span class="nc" id="L143">                statistics.getOrDefault(&quot;duplicatesFound&quot;, 0) - </span>
<span class="nc" id="L144">                statistics.getOrDefault(&quot;duplicatesResolved&quot;, 0)));</span>
<span class="nc" id="L145">        stats.put(&quot;averageProcessingTimeMs&quot;, 150); // Mock value</span>
<span class="nc" id="L146">        stats.put(&quot;lastProcessedAt&quot;, LocalDateTime.now());</span>
        
<span class="nc" id="L148">        return stats;</span>
    }

    @Override
    public void configureMatchingAlgorithm(String algorithm, Map&lt;String, Object&gt; parameters) {
<span class="nc" id="L153">        log.info(&quot;Configuring matching algorithm: {} with parameters: {}&quot;, algorithm, parameters);</span>
<span class="nc" id="L154">        algorithmConfig.put(algorithm, new HashMap&lt;&gt;(parameters));</span>
<span class="nc" id="L155">    }</span>
    
    /**
     * Calculate similarity between two entities
     */
    private double calculateSimilarity(Map&lt;String, Object&gt; entity1, Map&lt;String, Object&gt; entity2, 
                                     String[] matchingFields, String algorithm) {
        
<span class="nc bnc" id="L163" title="All 4 branches missed.">        if (matchingFields == null || matchingFields.length == 0) {</span>
            // Use default fields based on entity type
<span class="nc" id="L165">            matchingFields = getDefaultMatchingFields(entity1);</span>
        }
        
<span class="nc" id="L168">        double totalSimilarity = 0.0;</span>
<span class="nc" id="L169">        int fieldCount = 0;</span>
        
<span class="nc bnc" id="L171" title="All 2 branches missed.">        for (String field : matchingFields) {</span>
<span class="nc" id="L172">            Object value1 = entity1.get(field);</span>
<span class="nc" id="L173">            Object value2 = entity2.get(field);</span>
            
<span class="nc bnc" id="L175" title="All 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="nc" id="L176">                double fieldSimilarity = calculateFieldSimilarity(</span>
<span class="nc" id="L177">                        value1.toString(), value2.toString(), algorithm);</span>
<span class="nc" id="L178">                totalSimilarity += fieldSimilarity;</span>
<span class="nc" id="L179">                fieldCount++;</span>
            }
        }
        
<span class="nc bnc" id="L183" title="All 2 branches missed.">        return fieldCount &gt; 0 ? totalSimilarity / fieldCount : 0.0;</span>
    }
    
    /**
     * Calculate similarity between two field values
     */
    private double calculateFieldSimilarity(String value1, String value2, String algorithm) {
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (value1.equals(value2)) {</span>
<span class="nc" id="L191">            return 1.0;</span>
        }
        
<span class="nc bnc" id="L194" title="All 4 branches missed.">        switch (algorithm.toUpperCase()) {</span>
            case &quot;EXACT&quot;:
<span class="nc bnc" id="L196" title="All 2 branches missed.">                return value1.equalsIgnoreCase(value2) ? 1.0 : 0.0;</span>
            case &quot;FUZZY&quot;:
<span class="nc" id="L198">                return calculateJaroWinklerSimilarity(value1, value2);</span>
            case &quot;PHONETIC&quot;:
<span class="nc" id="L200">                return calculatePhoneticSimilarity(value1, value2);</span>
            default:
<span class="nc" id="L202">                return calculateLevenshteinSimilarity(value1, value2);</span>
        }
    }
    
    /**
     * Calculate Jaro-Winkler similarity
     */
    private double calculateJaroWinklerSimilarity(String s1, String s2) {
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (s1.equals(s2)) return 1.0;</span>
        
<span class="nc" id="L212">        int len1 = s1.length();</span>
<span class="nc" id="L213">        int len2 = s2.length();</span>
        
<span class="nc bnc" id="L215" title="All 4 branches missed.">        if (len1 == 0 || len2 == 0) return 0.0;</span>
        
<span class="nc" id="L217">        int matchDistance = Math.max(len1, len2) / 2 - 1;</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (matchDistance &lt; 0) matchDistance = 0;</span>
        
<span class="nc" id="L220">        boolean[] s1Matches = new boolean[len1];</span>
<span class="nc" id="L221">        boolean[] s2Matches = new boolean[len2];</span>
        
<span class="nc" id="L223">        int matches = 0;</span>
<span class="nc" id="L224">        int transpositions = 0;</span>
        
        // Find matches
<span class="nc bnc" id="L227" title="All 2 branches missed.">        for (int i = 0; i &lt; len1; i++) {</span>
<span class="nc" id="L228">            int start = Math.max(0, i - matchDistance);</span>
<span class="nc" id="L229">            int end = Math.min(i + matchDistance + 1, len2);</span>
            
<span class="nc bnc" id="L231" title="All 2 branches missed.">            for (int j = start; j &lt; end; j++) {</span>
<span class="nc bnc" id="L232" title="All 4 branches missed.">                if (s2Matches[j] || s1.charAt(i) != s2.charAt(j)) continue;</span>
<span class="nc" id="L233">                s1Matches[i] = true;</span>
<span class="nc" id="L234">                s2Matches[j] = true;</span>
<span class="nc" id="L235">                matches++;</span>
<span class="nc" id="L236">                break;</span>
            }
        }
        
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (matches == 0) return 0.0;</span>
        
        // Find transpositions
<span class="nc" id="L243">        int k = 0;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        for (int i = 0; i &lt; len1; i++) {</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">            if (!s1Matches[i]) continue;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            while (!s2Matches[k]) k++;</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (s1.charAt(i) != s2.charAt(k)) transpositions++;</span>
<span class="nc" id="L248">            k++;</span>
        }
        
<span class="nc" id="L251">        double jaro = (matches / (double) len1 + matches / (double) len2 + </span>
                      (matches - transpositions / 2.0) / matches) / 3.0;
        
        // Jaro-Winkler modification
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (jaro &lt; 0.7) return jaro;</span>
        
<span class="nc" id="L257">        int prefix = 0;</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">        for (int i = 0; i &lt; Math.min(len1, len2) &amp;&amp; i &lt; 4; i++) {</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (s1.charAt(i) == s2.charAt(i)) prefix++;</span>
            else break;
        }
        
<span class="nc" id="L263">        return jaro + (0.1 * prefix * (1.0 - jaro));</span>
    }
    
    /**
     * Calculate Levenshtein similarity
     */
    private double calculateLevenshteinSimilarity(String s1, String s2) {
<span class="nc" id="L270">        int distance = calculateLevenshteinDistance(s1, s2);</span>
<span class="nc" id="L271">        int maxLength = Math.max(s1.length(), s2.length());</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        return maxLength == 0 ? 1.0 : 1.0 - (double) distance / maxLength;</span>
    }
    
    /**
     * Calculate Levenshtein distance
     */
    private int calculateLevenshteinDistance(String s1, String s2) {
<span class="nc" id="L279">        int len1 = s1.length();</span>
<span class="nc" id="L280">        int len2 = s2.length();</span>
        
<span class="nc" id="L282">        int[][] dp = new int[len1 + 1][len2 + 1];</span>
        
<span class="nc bnc" id="L284" title="All 2 branches missed.">        for (int i = 0; i &lt;= len1; i++) dp[i][0] = i;</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        for (int j = 0; j &lt;= len2; j++) dp[0][j] = j;</span>
        
<span class="nc bnc" id="L287" title="All 2 branches missed.">        for (int i = 1; i &lt;= len1; i++) {</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            for (int j = 1; j &lt;= len2; j++) {</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                int cost = s1.charAt(i - 1) == s2.charAt(j - 1) ? 0 : 1;</span>
<span class="nc" id="L290">                dp[i][j] = Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), </span>
                                   dp[i - 1][j - 1] + cost);
            }
        }
        
<span class="nc" id="L295">        return dp[len1][len2];</span>
    }
    
    /**
     * Calculate phonetic similarity using Soundex-like algorithm
     */
    private double calculatePhoneticSimilarity(String s1, String s2) {
<span class="nc" id="L302">        String soundex1 = calculateSoundex(s1);</span>
<span class="nc" id="L303">        String soundex2 = calculateSoundex(s2);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        return soundex1.equals(soundex2) ? 1.0 : 0.0;</span>
    }
    
    /**
     * Calculate Soundex code
     */
    private String calculateSoundex(String s) {
<span class="nc bnc" id="L311" title="All 4 branches missed.">        if (s == null || s.isEmpty()) return &quot;0000&quot;;</span>
        
<span class="nc" id="L313">        s = s.toUpperCase().replaceAll(&quot;[^A-Z]&quot;, &quot;&quot;);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (s.isEmpty()) return &quot;0000&quot;;</span>
        
<span class="nc" id="L316">        StringBuilder soundex = new StringBuilder();</span>
<span class="nc" id="L317">        soundex.append(s.charAt(0));</span>
        
<span class="nc" id="L319">        String mapping = &quot;01230120022455012623010202&quot;;</span>
<span class="nc" id="L320">        char prevCode = mapping.charAt(s.charAt(0) - 'A');</span>
        
<span class="nc bnc" id="L322" title="All 4 branches missed.">        for (int i = 1; i &lt; s.length() &amp;&amp; soundex.length() &lt; 4; i++) {</span>
<span class="nc" id="L323">            char code = mapping.charAt(s.charAt(i) - 'A');</span>
<span class="nc bnc" id="L324" title="All 4 branches missed.">            if (code != '0' &amp;&amp; code != prevCode) {</span>
<span class="nc" id="L325">                soundex.append(code);</span>
            }
<span class="nc" id="L327">            prevCode = code;</span>
        }
        
<span class="nc bnc" id="L330" title="All 2 branches missed.">        while (soundex.length() &lt; 4) {</span>
<span class="nc" id="L331">            soundex.append('0');</span>
        }
        
<span class="nc" id="L334">        return soundex.toString();</span>
    }

    /**
     * Get default matching fields based on entity data
     */
    private String[] getDefaultMatchingFields(Map&lt;String, Object&gt; entity) {
<span class="nc" id="L341">        Set&lt;String&gt; fields = new HashSet&lt;&gt;();</span>

        // Common fields for all entities
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (entity.containsKey(&quot;firstName&quot;)) fields.add(&quot;firstName&quot;);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (entity.containsKey(&quot;lastName&quot;)) fields.add(&quot;lastName&quot;);</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (entity.containsKey(&quot;psn&quot;)) fields.add(&quot;psn&quot;);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (entity.containsKey(&quot;dateOfBirth&quot;)) fields.add(&quot;dateOfBirth&quot;);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (entity.containsKey(&quot;email&quot;)) fields.add(&quot;email&quot;);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (entity.containsKey(&quot;phoneNumber&quot;)) fields.add(&quot;phoneNumber&quot;);</span>

        // Household-specific fields
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (entity.containsKey(&quot;householdNumber&quot;)) fields.add(&quot;householdNumber&quot;);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (entity.containsKey(&quot;address&quot;)) fields.add(&quot;address&quot;);</span>

<span class="nc" id="L355">        return fields.toArray(new String[0]);</span>
    }

    /**
     * Create a duplicate match object
     */
    private DeduplicationResponse.DuplicateMatch createDuplicateMatch(
            Map&lt;String, Object&gt; existingEntity, double similarity, DeduplicationRequest request) {

<span class="nc" id="L364">        DeduplicationResponse.DuplicateMatch match = new DeduplicationResponse.DuplicateMatch();</span>
<span class="nc" id="L365">        match.setExistingEntityId(UUID.randomUUID()); // In production, get from entity</span>
<span class="nc" id="L366">        match.setSimilarityScore(similarity);</span>
<span class="nc" id="L367">        match.setMatchType(request.getMatchingAlgorithm());</span>
<span class="nc" id="L368">        match.setExistingEntityData(new HashMap&lt;&gt;(existingEntity));</span>

        // Create field matches
<span class="nc" id="L371">        List&lt;DeduplicationResponse.FieldMatch&gt; fieldMatches = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L372">        String[] matchingFields = request.getMatchingFields();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (matchingFields == null) {</span>
<span class="nc" id="L374">            matchingFields = getDefaultMatchingFields(request.getEntityData());</span>
        }

<span class="nc bnc" id="L377" title="All 2 branches missed.">        for (String field : matchingFields) {</span>
<span class="nc" id="L378">            Object newValue = request.getEntityData().get(field);</span>
<span class="nc" id="L379">            Object existingValue = existingEntity.get(field);</span>

<span class="nc bnc" id="L381" title="All 4 branches missed.">            if (newValue != null &amp;&amp; existingValue != null) {</span>
<span class="nc" id="L382">                double fieldSimilarity = calculateFieldSimilarity(</span>
<span class="nc" id="L383">                        newValue.toString(), existingValue.toString(), request.getMatchingAlgorithm());</span>

<span class="nc bnc" id="L385" title="All 2 branches missed.">                if (fieldSimilarity &gt; 0.5) { // Only include significant matches</span>
<span class="nc" id="L386">                    DeduplicationResponse.FieldMatch fieldMatch = new DeduplicationResponse.FieldMatch();</span>
<span class="nc" id="L387">                    fieldMatch.setFieldName(field);</span>
<span class="nc" id="L388">                    fieldMatch.setNewValue(newValue.toString());</span>
<span class="nc" id="L389">                    fieldMatch.setExistingValue(existingValue.toString());</span>
<span class="nc" id="L390">                    fieldMatch.setFieldSimilarity(fieldSimilarity);</span>
<span class="nc" id="L391">                    fieldMatch.setMatchReason(getMatchReason(fieldSimilarity, request.getMatchingAlgorithm()));</span>

<span class="nc" id="L393">                    fieldMatches.add(fieldMatch);</span>
                }
            }
        }

<span class="nc" id="L398">        match.setFieldMatches(fieldMatches);</span>
<span class="nc" id="L399">        return match;</span>
    }

    /**
     * Determine recommendation based on matches
     */
    private String determineRecommendation(List&lt;DeduplicationResponse.DuplicateMatch&gt; matches, double threshold) {
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (matches.isEmpty()) {</span>
<span class="nc" id="L407">            return &quot;PROCEED&quot;;</span>
        }

<span class="nc" id="L410">        double highestScore = matches.get(0).getSimilarityScore();</span>

<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (highestScore &gt;= HIGH_CONFIDENCE_THRESHOLD) {</span>
<span class="nc" id="L413">            return &quot;REJECT&quot;; // Very likely duplicate</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">        } else if (highestScore &gt;= threshold) {</span>
<span class="nc" id="L415">            return &quot;REVIEW_REQUIRED&quot;; // Possible duplicate, needs human review</span>
        } else {
<span class="nc" id="L417">            return &quot;PROCEED&quot;; // Low confidence, proceed with caution</span>
        }
    }

    /**
     * Get match reason based on similarity score and algorithm
     */
    private String getMatchReason(double similarity, String algorithm) {
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (similarity &gt;= 0.95) {</span>
<span class="nc" id="L426">            return &quot;Exact match&quot;;</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        } else if (similarity &gt;= 0.85) {</span>
<span class="nc" id="L428">            return &quot;Very high similarity&quot;;</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        } else if (similarity &gt;= 0.75) {</span>
<span class="nc" id="L430">            return &quot;High similarity&quot;;</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">        } else if (similarity &gt;= 0.65) {</span>
<span class="nc" id="L432">            return &quot;Moderate similarity&quot;;</span>
        } else {
<span class="nc" id="L434">            return &quot;Low similarity&quot;;</span>
        }
    }

    /**
     * Update statistics
     */
    private void updateStatistics(String key, int increment) {
<span class="nc" id="L442">        statistics.put(key, statistics.getOrDefault(key, 0) + increment);</span>
<span class="nc" id="L443">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>